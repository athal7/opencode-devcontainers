#!/usr/bin/env bash
#
# ocdc-tui - Interactive TUI for managing devcontainer instances
#
# Usage:
#   ocdc tui              # Launch interactive TUI
#
# Navigation:
#   ↑/↓ or j/k         Move selection up/down
#   Enter              Open/start selected instance
#   n                  New devcontainer (prompts for branch)
#   d                  Delete selected (respects git safety)
#   D                  Delete all safe orphans
#   r                  Refresh list
#   q                  Quit
#
# Related commands:
#   ocdc up     - Start devcontainer
#   ocdc down   - Stop devcontainer  
#   ocdc list   - List instances (non-interactive)
#   ocdc clean  - Clean up orphaned clones

set -euo pipefail

# Source paths library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/ocdc-paths.bash"

CACHE_DIR="$OCDC_CACHE_DIR"
PORTS_FILE="$OCDC_PORTS_FILE"
CLONES_DIR="$OCDC_CLONES_DIR"

# Check dependencies
command -v jq >/dev/null 2>&1 || { echo "Error: jq is required"; exit 1; }

# Colors and styles
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'
CYAN='\033[36m'
GREEN='\033[32m'
RED='\033[31m'
YELLOW='\033[33m'
BLUE='\033[34m'
BG_BLUE='\033[44m'
BG_RESET='\033[49m'

# Layout configuration
MIN_REPO_WIDTH=12
MIN_BRANCH_WIDTH=12
MAX_CONTENT_WIDTH=130
PORT_WIDTH=6
STATUS_WIDTH=8
GIT_WIDTH=10

# Layout variables (set by calculate_layout)
REPO_WIDTH=$MIN_REPO_WIDTH
BRANCH_WIDTH=$MIN_BRANCH_WIDTH
LEFT_PADDING=2
TOP_PADDING=0

# Calculate layout based on terminal dimensions
calculate_layout() {
  local cols="${1:-$(tput cols 2>/dev/null || echo 80)}"
  local rows="${2:-$(tput lines 2>/dev/null || echo 24)}"
  local instance_count="${3:-0}"
  
  # Fixed widths: port(6) + status(8) + git(10) + spaces between columns(8) + selection marker(2)
  local fixed_width=$((PORT_WIDTH + STATUS_WIDTH + GIT_WIDTH + 8 + 2))
  
  # Available space for repo + branch columns
  local available=$((cols - fixed_width - 4))
  
  # Guard against negative available space on very narrow terminals
  [[ $available -lt 0 ]] && available=0
  
  # Cap available space to max content width
  if [[ $available -gt $((MAX_CONTENT_WIDTH - fixed_width)) ]]; then
    available=$((MAX_CONTENT_WIDTH - fixed_width))
  fi
  
  # Distribute space: 40% to repo, 60% to branch
  REPO_WIDTH=$((available * 40 / 100))
  BRANCH_WIDTH=$((available * 60 / 100))
  
  # Enforce minimums
  [[ $REPO_WIDTH -lt $MIN_REPO_WIDTH ]] && REPO_WIDTH=$MIN_REPO_WIDTH
  [[ $BRANCH_WIDTH -lt $MIN_BRANCH_WIDTH ]] && BRANCH_WIDTH=$MIN_BRANCH_WIDTH
  
  # Calculate horizontal centering padding for wide terminals
  local content_width=$((PORT_WIDTH + REPO_WIDTH + BRANCH_WIDTH + STATUS_WIDTH + GIT_WIDTH + 8))
  if [[ $cols -gt $((content_width + 4)) ]]; then
    LEFT_PADDING=$(( (cols - content_width) / 2 ))
  else
    LEFT_PADDING=2
  fi
  
  # Calculate vertical centering
  local content_height=$((2 + 2 + instance_count + 2 + 4))
  [[ $instance_count -eq 0 ]] && content_height=10
  
  if [[ $rows -gt $((content_height + 4)) ]]; then
    TOP_PADDING=$(( (rows - content_height) / 3 ))
  else
    TOP_PADDING=0
  fi
}

# Detect if running in VS Code integrated terminal
is_vscode_terminal() {
  [[ -n "${TERM_PROGRAM:-}" ]] && [[ "$TERM_PROGRAM" == "vscode" ]]
}

# Check if port is active
is_port_active() {
  lsof -i ":$1" >/dev/null 2>&1
}

# Get tracked workspaces
get_tracked_workspaces() {
  if [[ -f "$PORTS_FILE" ]]; then
    jq -r 'keys[]' "$PORTS_FILE" 2>/dev/null || true
  fi
}



# Format git status for display
format_git_status() {
  local workspace="$1"
  
  if [[ ! -d "$workspace" ]]; then
    echo "-"
    return
  fi
  
  local git_info
  git_info=$(ocdc_get_git_status "$workspace" 2>/dev/null || echo '{"clean":true,"pushed":true,"ahead":0,"is_git":false}')
  
  local is_git clean pushed ahead
  is_git=$(echo "$git_info" | jq -r '.is_git')
  
  if [[ "$is_git" == "false" ]]; then
    echo "-"
    return
  fi
  
  clean=$(echo "$git_info" | jq -r '.clean')
  pushed=$(echo "$git_info" | jq -r '.pushed')
  ahead=$(echo "$git_info" | jq -r '.ahead')
  
  if [[ "$clean" == "false" ]]; then
    echo "dirty"
  elif [[ "$pushed" == "false" ]]; then
    echo "↑$ahead"
  else
    echo "clean"
  fi
}

# Load all instances (tracked containers + orphaned clones)
load_instances() {
  TYPES=()        # "container" or "orphan"
  PORTS=()
  REPOS=()
  BRANCHES=()
  STATUSES=()
  WORKSPACES=()
  GIT_STATUSES=()
  
  local tracked
  tracked=$(get_tracked_workspaces)
  
  # Load tracked containers from ports.json
  if [[ -f "$PORTS_FILE" ]]; then
    local port repo branch workspace
    while IFS=$'\t' read -r port repo branch workspace; do
      [[ -n "$port" ]] || continue
      TYPES+=("container")
      PORTS+=("$port")
      REPOS+=("$repo")
      BRANCHES+=("$branch")
      WORKSPACES+=("$workspace")
      GIT_STATUSES+=("$(format_git_status "$workspace")")
      if is_port_active "$port"; then
        STATUSES+=("UP")
      else
        STATUSES+=("DOWN")
      fi
    done < <(jq -r 'to_entries[] | "\(.value.port)\t\(.value.repo)\t\(.value.branch)\t\(.key)"' "$PORTS_FILE" 2>/dev/null)
  fi
  
  # Load orphaned clones (exist on disk but not tracked)
  if [[ -d "$CLONES_DIR" ]]; then
    local repo_dir repo_name clone_dir branch_name
    for repo_dir in "$CLONES_DIR"/*/; do
      [[ -d "$repo_dir" ]] || continue
      repo_name=$(basename "$repo_dir")
      
      for clone_dir in "$repo_dir"*/; do
        [[ -d "$clone_dir" ]] || continue
        clone_dir="${clone_dir%/}"
        
        # Skip if tracked
        if echo "$tracked" | grep -qFx "$clone_dir" 2>/dev/null; then
          continue
        fi
        
        branch_name=$(basename "$clone_dir")
        TYPES+=("orphan")
        PORTS+=("-")
        REPOS+=("$repo_name")
        BRANCHES+=("$branch_name")
        STATUSES+=("ORPHAN")
        WORKSPACES+=("$clone_dir")
        GIT_STATUSES+=("$(format_git_status "$clone_dir")")
      done
    done
  fi
}

# Generate padding string
make_padding() {
  local n="$1"
  printf "%${n}s" ""
}

# Generate separator line of given width
make_separator() {
  local n="$1"
  local sep=""
  for ((i=0; i<n; i++)); do
    sep+="─"
  done
  echo "$sep"
}

# Get terminal dimensions
get_terminal_size() {
  local size
  if size=$(stty size 2>/dev/null); then
    echo "$size"
  elif [[ -n "${LINES:-}" ]] && [[ -n "${COLUMNS:-}" ]]; then
    echo "$LINES $COLUMNS"
  else
    echo "$(tput lines 2>/dev/null || echo 24) $(tput cols 2>/dev/null || echo 80)"
  fi
}

# Draw the TUI
draw_screen() {
  clear
  local term_size
  term_size=$(get_terminal_size)
  local rows=${term_size%% *}
  local cols=${term_size##* }
  
  calculate_layout "$cols" "$rows" "${#TYPES[@]}"
  local pad=$(make_padding $LEFT_PADDING)
  
  # Vertical padding for tall terminals
  for ((i=0; i<TOP_PADDING; i++)); do
    echo ""
  done
  
  # Header (centered)
  local header_pad=$(( (cols - 14) / 2 ))
  [[ $header_pad -lt 2 ]] && header_pad=2
  printf "%${header_pad}s" ""
  echo -e "${BOLD}${CYAN}⚡ ocdc ⚡${RESET}"
  echo ""
  
  if [[ ${#TYPES[@]} -eq 0 ]]; then
    echo "${pad}No devcontainer instances or clones found."
    echo ""
    echo -e "${pad}${DIM}Press${RESET} ${BOLD}n${RESET} ${DIM}to create a new devcontainer${RESET}"
  else
    # Table header with dynamic widths
    printf "${pad}${BOLD}%-${PORT_WIDTH}s  %-${REPO_WIDTH}s  %-${BRANCH_WIDTH}s  %-${STATUS_WIDTH}s  %-${GIT_WIDTH}s${RESET}\n" \
      "PORT" "REPO" "BRANCH" "STATUS" "GIT"
    printf "${pad}${DIM}%-${PORT_WIDTH}s  %-${REPO_WIDTH}s  %-${BRANCH_WIDTH}s  %-${STATUS_WIDTH}s  %-${GIT_WIDTH}s${RESET}\n" \
      "$(make_separator $PORT_WIDTH)" "$(make_separator $REPO_WIDTH)" "$(make_separator $BRANCH_WIDTH)" "$(make_separator $STATUS_WIDTH)" "$(make_separator $GIT_WIDTH)"
    
    # Instances
    for i in "${!TYPES[@]}"; do
      local prefix="${pad}"
      local suffix=""
      
      # Highlight selected row
      if [[ $i -eq $SELECTED ]]; then
        prefix="${pad}${BG_BLUE}${BOLD}▸ "
        suffix="${RESET}"
      fi
      
      # Status color
      local status_color=""
      case "${STATUSES[$i]}" in
        UP)      status_color="${GREEN}" ;;
        DOWN)    status_color="${RED}" ;;
        ORPHAN)  status_color="${YELLOW}" ;;
      esac
      
      # Git status color
      local git_color=""
      local git_val="${GIT_STATUSES[$i]}"
      case "$git_val" in
        clean) git_color="${GREEN}" ;;
        dirty) git_color="${RED}" ;;
        ↑*)    git_color="${YELLOW}" ;;
        *)     git_color="${DIM}" ;;
      esac
      
      # Truncate long values to fit columns
      local repo="${REPOS[$i]}"
      local branch="${BRANCHES[$i]}"
      [[ ${#repo} -gt $REPO_WIDTH ]] && repo="${repo:0:$((REPO_WIDTH - 3))}..."
      [[ ${#branch} -gt $BRANCH_WIDTH ]] && branch="${branch:0:$((BRANCH_WIDTH - 3))}..."
      
      printf "${prefix}%-${PORT_WIDTH}s  %-${REPO_WIDTH}s  %-${BRANCH_WIDTH}s  ${status_color}%-${STATUS_WIDTH}s${RESET}  ${git_color}%-${GIT_WIDTH}s${RESET}${suffix}\n" \
        "${PORTS[$i]}" "$repo" "$branch" "${STATUSES[$i]}" "$git_val"
    done
    
    # Show workspace path for selected item
    echo ""
    echo -e "${pad}${DIM}Path: ${WORKSPACES[$SELECTED]}${RESET}"
  fi
  
  # Footer with keybindings
  local footer_width=$((PORT_WIDTH + REPO_WIDTH + BRANCH_WIDTH + STATUS_WIDTH + GIT_WIDTH + 8))
  echo ""
  echo -e "${pad}${DIM}$(make_separator $footer_width)${RESET}"
  echo -e "${pad}${BOLD}n${RESET}${DIM}ew${RESET}  ${BOLD}d${RESET}${DIM}elete${RESET}  ${BOLD}D${RESET}${DIM}elete-all-safe${RESET}  ${BOLD}r${RESET}${DIM}efresh${RESET}  ${BOLD}q${RESET}${DIM}uit${RESET}"
  
  if [[ ${#TYPES[@]} -gt 0 ]]; then
    local status="${STATUSES[$SELECTED]}"
    if [[ "$status" == "UP" ]]; then
      echo -e "${pad}${DIM}↑/↓ navigate  Enter=open in VS Code${RESET}"
    elif [[ "$status" == "DOWN" ]]; then
      echo -e "${pad}${DIM}↑/↓ navigate  Enter=start container${RESET}"
    else
      echo -e "${pad}${DIM}↑/↓ navigate  Enter=open directory${RESET}"
    fi
  fi
}

# Show confirmation dialog
confirm() {
  local message="$1"
  local default="${2:-n}"
  
  echo ""
  if [[ "$default" == "y" ]]; then
    echo -ne "  ${message} [Y/n] "
  else
    echo -ne "  ${message} [y/N] "
  fi
  
  read -rsn1 reply
  echo ""
  
  case "$reply" in
    y|Y) return 0 ;;
    n|N) return 1 ;;
    "")  [[ "$default" == "y" ]] && return 0 || return 1 ;;
    *)   return 1 ;;
  esac
}

# Handle opening/starting a workspace
open_workspace() {
  local idx=$1
  local workspace="${WORKSPACES[$idx]}"
  local status="${STATUSES[$idx]}"
  
  # If container is DOWN, start it first then open
  if [[ "$status" == "DOWN" ]]; then
    clear
    tput cnorm
    echo "Starting container for ${REPOS[$idx]}/${BRANCHES[$idx]}..."
    echo ""
    (cd "$workspace" && ocdc up --no-open) 2>&1 || true
    load_instances
    tput civis
  fi
  
  # Open in VS Code or show cd command
  if is_vscode_terminal; then
    code "$workspace"
  else
    clear
    echo "To navigate to the workspace:"
    echo ""
    echo -e "  ${BOLD}cd $workspace${RESET}"
    echo ""
    echo "Press any key to continue..."
    read -rsn1
  fi
}

# Stop/remove an instance with git safety check
stop_instance() {
  local idx=$1
  local workspace="${WORKSPACES[$idx]}"
  local type="${TYPES[$idx]}"
  local repo="${REPOS[$idx]}"
  local branch="${BRANCHES[$idx]}"
  local git_status="${GIT_STATUSES[$idx]}"
  
  clear
  tput cnorm
  
  # Check git safety
  local is_safe=true
  local unsafe_reason=""
  
  if [[ -d "$workspace" ]] && ! ocdc_is_safe_to_remove "$workspace"; then
    is_safe=false
    if [[ "$git_status" == "dirty" ]]; then
      unsafe_reason="uncommitted changes"
    else
      unsafe_reason="unpushed commits"
    fi
  fi
  
  if [[ "$type" == "orphan" ]]; then
    # Orphan clone - offer to remove
    echo -e "Remove orphaned clone ${BOLD}${repo}/${branch}${RESET}?"
    echo -e "${DIM}Path: ${workspace}${RESET}"
    
    if [[ "$is_safe" == "false" ]]; then
      echo -e "${RED}Warning: Workspace has ${unsafe_reason}!${RESET}"
      echo ""
      if confirm "Remove anyway? (DANGEROUS)"; then
        rm -rf "$workspace"
        local parent=$(dirname "$workspace")
        [[ -d "$parent" ]] && [[ -z "$(ls -A "$parent")" ]] && rmdir "$parent" 2>/dev/null || true
        echo "  Removed."
      else
        echo "  Cancelled."
      fi
    else
      echo ""
      if confirm "Remove clone directory?"; then
        rm -rf "$workspace"
        local parent=$(dirname "$workspace")
        [[ -d "$parent" ]] && [[ -z "$(ls -A "$parent")" ]] && rmdir "$parent" 2>/dev/null || true
        echo "  Removed."
      else
        echo "  Cancelled."
      fi
    fi
  else
    # Container - stop it and optionally remove clone
    echo -e "Stopping ${BOLD}${repo}/${branch}${RESET} (port ${PORTS[$idx]})..."
    ocdc down "$workspace" 2>&1 || true
    
    # If it's a clone, offer to remove it
    if [[ "$workspace" == "$CLONES_DIR"* ]]; then
      echo ""
      if [[ "$is_safe" == "true" ]]; then
        if confirm "Also remove the clone directory?"; then
          rm -rf "$workspace"
          local parent=$(dirname "$workspace")
          [[ -d "$parent" ]] && [[ -z "$(ls -A "$parent")" ]] && rmdir "$parent" 2>/dev/null || true
          echo "  Clone removed."
        fi
      else
        echo -e "${DIM}Clone not removed (has ${unsafe_reason})${RESET}"
      fi
    fi
  fi
  
  echo ""
  echo "Press any key to continue..."
  read -rsn1
  tput civis
}

# Prompt for branch name
prompt_branch() {
  clear >&2
  tput cnorm >&2
  echo "" >&2
  echo "  ╭─────────────────────────────────────────╮" >&2
  echo "  │         Start devcontainer             │" >&2
  echo "  ├─────────────────────────────────────────┤" >&2
  echo "  │  Enter a branch name to create a clone │" >&2
  echo "  │  or press Enter for current directory  │" >&2
  echo "  ╰─────────────────────────────────────────╯" >&2
  echo "" >&2
  echo -n "  Branch: " >&2
  read -r branch
  tput civis >&2
  echo "$branch"
}

# Main loop
main() {
  SELECTED=0
  load_instances
  
  # Hide cursor
  tput civis
  trap 'tput cnorm; clear' EXIT
  
  # Redraw on terminal resize
  trap 'draw_screen' WINCH
  
  while true; do
    draw_screen
    
    # Read single key with timeout to allow resize redraw
    read -rsn1 -t 1 key || continue
    
    # Handle escape sequences (arrows)
    if [[ "$key" == $'\x1b' ]]; then
      read -rsn2 -t 0.1 key2 || true
      key="${key}${key2}"
    fi
    
    case "$key" in
      q|Q)
        break
        ;;
      
      # Navigation - down
      j|$'\x1b[B')
        if [[ ${#TYPES[@]} -gt 0 ]] && [[ $SELECTED -lt $((${#TYPES[@]} - 1)) ]]; then
          SELECTED=$((SELECTED + 1))
        fi
        ;;
      
      # Navigation - up  
      k|$'\x1b[A')
        if [[ $SELECTED -gt 0 ]]; then
          SELECTED=$((SELECTED - 1))
        fi
        ;;
      
      # Open workspace
      ''|$'\n')
        if [[ ${#TYPES[@]} -gt 0 ]]; then
          open_workspace $SELECTED
        fi
        ;;
      
      # New devcontainer (prompt for branch)
      n|N)
        branch=$(prompt_branch)
        clear
        tput cnorm
        
        if [[ -n "$branch" ]]; then
          # Check if this branch already exists in the list
          local found_idx=-1
          for i in "${!BRANCHES[@]}"; do
            if [[ "${BRANCHES[$i]}" == "$branch" ]]; then
              found_idx=$i
              break
            fi
          done
          
          if [[ $found_idx -ge 0 ]]; then
            echo "Branch '$branch' already exists - opening it..."
            sleep 1
            tput civis
            open_workspace $found_idx
            load_instances
            continue
          fi
          
          ocdc up "$branch" --no-open || true
        else
          ocdc up --no-open || true
        fi
        echo ""
        echo "Press any key to continue..."
        read -rsn1
        tput civis
        load_instances
        ;;
      
      # Stop/delete selected
      d|x)
        if [[ ${#TYPES[@]} -gt 0 ]]; then
          stop_instance $SELECTED
          load_instances
          [[ $SELECTED -ge ${#TYPES[@]} ]] && SELECTED=$((${#TYPES[@]} - 1))
          [[ $SELECTED -lt 0 ]] && SELECTED=0
        fi
        ;;
      
      # Delete all safe orphans
      D|X)
        clear
        tput cnorm
        echo "This will clean up all safe orphaned clones."
        echo "Clones with uncommitted/unpushed changes will be skipped."
        echo ""
        if confirm "Clean all safe orphans?"; then
          ocdc clean 2>&1 || true
        fi
        echo ""
        echo "Press any key to continue..."
        read -rsn1
        tput civis
        load_instances
        SELECTED=0
        ;;
      
      # Refresh
      r|R)
        load_instances
        [[ $SELECTED -ge ${#TYPES[@]} ]] && SELECTED=$((${#TYPES[@]} - 1))
        [[ $SELECTED -lt 0 ]] && SELECTED=0
        ;;
    esac
  done
}

# Show help
if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
  sed -n '2,/^$/p' "$0" | sed 's/^# //' | sed 's/^#//'
  exit 0
fi

main
