#!/usr/bin/env bash
#
# ocdc-poll - Poll orchestrator for automated devcontainer sessions
#
# Usage:
#   ocdc poll [--once] [--dry-run] [--config <name>]
#   ocdc poll sessions           # List active poll sessions
#   ocdc poll attach <pattern>   # Attach to a session
#   ocdc poll logs [--follow]    # View poll logs
#
# Options:
#   --once      Run one poll cycle and exit (default)
#   --dry-run   Show what would be done without executing
#   --config    Only run specific config by id

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BIN_DIR="$(dirname "$SCRIPT_DIR")/bin"
source "${SCRIPT_DIR}/ocdc-paths.bash"
source "${SCRIPT_DIR}/ocdc-poll-config.bash"
source "${SCRIPT_DIR}/ocdc-file-lock.bash"
source "${SCRIPT_DIR}/ocdc-poll-errors.bash"
source "${SCRIPT_DIR}/ocdc-poll-cleanup.bash"
source "${SCRIPT_DIR}/ocdc-sessions.bash"

# Ensure ocdc commands are available
export PATH="$BIN_DIR:$PATH"

# State file for tracking processed items
STATE_FILE="${OCDC_POLL_STATE_DIR}/processed.json"

# Ensure state directory and file exist
mkdir -p "$OCDC_POLL_STATE_DIR"
mkdir -p "$OCDC_POLL_LOG_DIR"
[[ -f "$STATE_FILE" ]] || echo '{}' > "$STATE_FILE"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Options
DRY_RUN=false
SINGLE_CONFIG=""
VERBOSE=false
DAEMON=false
INTERVAL=300
SKIP_CLEANUP=false
MAX_CONCURRENT=1

# Current poll ID for structured logging
CURRENT_POLL_ID=""

# =============================================================================
# Logging with file output
# =============================================================================

# Rotate log file if it exceeds max lines
# Usage: rotate_log_if_needed [log_file] [max_lines] [keep_lines]
rotate_log_if_needed() {
  local log_file="${1:-$OCDC_POLL_LOG_FILE}"
  local max_lines="${2:-10000}"
  local keep_lines="${3:-5000}"
  
  [[ ! -f "$log_file" ]] && return 0
  
  local current_lines
  current_lines=$(wc -l < "$log_file" 2>/dev/null | tr -d ' ' || echo 0)
  
  if [[ $current_lines -gt $max_lines ]]; then
    local tmp_file="${log_file}.tmp"
    tail -n "$keep_lines" "$log_file" > "$tmp_file"
    mv "$tmp_file" "$log_file"
  fi
}

# Write log entry to file with timestamp and optional poll ID
_log_to_file() {
  local message="$1"
  
  # Ensure log directory exists
  mkdir -p "$OCDC_POLL_LOG_DIR"
  
  # Rotate if needed (check every write, cheap operation)
  rotate_log_if_needed
  
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  local prefix=""
  [[ -n "$CURRENT_POLL_ID" ]] && prefix="[$CURRENT_POLL_ID] "
  
  echo "${timestamp} ${prefix}${message}" >> "$OCDC_POLL_LOG_FILE"
}

log() {
  echo -e "${BLUE}[poll]${NC} $*" >&2
  _log_to_file "INFO: $*"
}

log_success() {
  echo -e "${GREEN}[poll]${NC} $*" >&2
  _log_to_file "INFO: $*"
}

log_warn() {
  echo -e "${YELLOW}[poll]${NC} $*" >&2
  _log_to_file "WARN: $*"
}

log_error() {
  echo -e "${RED}[poll]${NC} $*" >&2
  _log_to_file "ERROR: $*"
}

# =============================================================================
# Session Management Functions
# =============================================================================

# Convert seconds to human-readable age (e.g., "2h", "30m", "1d")
format_age() {
  local seconds="$1"
  if [[ $seconds -lt 60 ]]; then
    echo "${seconds}s"
  elif [[ $seconds -lt 3600 ]]; then
    echo "$((seconds / 60))m"
  elif [[ $seconds -lt 86400 ]]; then
    echo "$((seconds / 3600))h"
  else
    echo "$((seconds / 86400))d"
  fi
}

# Get OCDC metadata from a tmux session
# Returns JSON: {"poll": "...", "key": "...", "workspace": "...", "created": "..."}
get_session_metadata() {
  local session="$1"
  local env_output
  env_output=$(tmux show-environment -t "$session" 2>/dev/null) || return 1
  
  # Parse OCDC_* variables from output
  local poll_config key workspace
  poll_config=$(echo "$env_output" | grep '^OCDC_POLL_CONFIG=' | cut -d= -f2- || true)
  key=$(echo "$env_output" | grep '^OCDC_ITEM_KEY=' | cut -d= -f2- || true)
  workspace=$(echo "$env_output" | grep '^OCDC_WORKSPACE=' | cut -d= -f2- || true)
  
  # Get session creation time for age calculation
  local created
  created=$(tmux display-message -t "$session" -p '#{session_created}' 2>/dev/null || echo "0")
  
  jq -n --arg poll "$poll_config" --arg key "$key" \
        --arg workspace "$workspace" --arg created "$created" \
    '{poll: $poll, key: $key, workspace: $workspace, created: $created}'
}

# Find sessions matching a pattern
# Returns newline-separated list of "session_name|item_key" pairs
find_matching_sessions() {
  local pattern="$1"
  
  while IFS= read -r session; do
    [[ -z "$session" ]] && continue
    
    local metadata key poll_config
    metadata=$(get_session_metadata "$session") || continue
    poll_config=$(echo "$metadata" | jq -r '.poll // empty')
    [[ -z "$poll_config" ]] && continue  # Not an ocdc poll session
    
    key=$(echo "$metadata" | jq -r '.key // empty')
    
    # Check for match: exact key, substring key, or substring session name
    if [[ "$key" == "$pattern" ]] || \
       [[ "$key" == *"$pattern"* ]] || \
       [[ "$session" == *"$pattern"* ]]; then
      echo "${session}|${key}"
    fi
  done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null)
}

# Interactive session selection
# Args: session_name|key pairs
# Returns: selected session_name|key pair
select_session() {
  local -a sessions=("$@")
  local count=${#sessions[@]}
  
  if [[ $count -eq 0 ]]; then
    return 1
  elif [[ $count -eq 1 ]]; then
    echo "${sessions[0]}"
    return 0
  fi
  
  # Check if interactive
  if [[ ! -t 0 ]]; then
    log_error "Multiple matches found. Specify a more precise pattern."
    return 1
  fi
  
  echo "Multiple sessions match:" >&2
  for i in "${!sessions[@]}"; do
    local session key
    session="${sessions[$i]%%|*}"
    key="${sessions[$i]#*|}"
    printf "  %d) %s (%s)\n" "$((i+1))" "$session" "$key" >&2
  done
  
  echo -n "Select [1-$count]: " >&2
  read -r choice
  
  if [[ "$choice" =~ ^[0-9]+$ ]] && [[ $choice -ge 1 ]] && [[ $choice -le $count ]]; then
    echo "${sessions[$((choice-1))]}"
    return 0
  else
    log_error "Invalid selection."
    return 1
  fi
}

# =============================================================================
# Subcommand: sessions
# =============================================================================

poll_sessions_cmd() {
  # Handle --help
  if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
Usage: ocdc poll sessions

List active poll-created tmux sessions.

Output columns:
  SESSION   tmux session name
  POLL      poll config ID that created the session
  ITEM      item key (e.g., owner/repo-issue-42)
  AGE       time since session was created
EOF
    return 0
  fi
  
  local now
  now=$(date +%s)
  
  # Header
  printf "%-30s %-16s %-24s %s\n" "SESSION" "POLL" "ITEM" "AGE"
  
  # List all tmux sessions, filter to those with OCDC_POLL_CONFIG
  local found=false
  while IFS= read -r session; do
    [[ -z "$session" ]] && continue
    
    local metadata
    metadata=$(get_session_metadata "$session") || continue
    
    local poll_config key created
    poll_config=$(echo "$metadata" | jq -r '.poll // empty')
    [[ -z "$poll_config" ]] && continue  # Not an ocdc poll session
    
    key=$(echo "$metadata" | jq -r '.key // "unknown"')
    created=$(echo "$metadata" | jq -r '.created // "0"')
    
    local age_seconds age
    age_seconds=$((now - created))
    [[ $age_seconds -lt 0 ]] && age_seconds=0  # Handle clock skew
    age=$(format_age "$age_seconds")
    
    printf "%-30s %-16s %-24s %s\n" "$session" "$poll_config" "$key" "$age"
    found=true
  done < <(tmux list-sessions -F '#{session_name}' 2>/dev/null)
  
  if [[ "$found" == "false" ]]; then
    echo "No active poll sessions." >&2
  fi
}

# =============================================================================
# Subcommand: attach
# =============================================================================

poll_attach_cmd() {
  if [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
    cat << 'EOF'
Usage: ocdc poll attach <pattern>

Attach to a poll-created tmux session.

Arguments:
  pattern    Item key or session name (partial match supported)

Examples:
  ocdc poll attach myorg/api-issue-42    # Exact key match
  ocdc poll attach issue-42              # Partial match
  ocdc poll attach api                   # Interactive if multiple
EOF
    return 0
  fi
  
  if [[ $# -eq 0 ]]; then
    log_error "Usage: ocdc poll attach <pattern>"
    log_error "Run 'ocdc poll attach --help' for more information."
    return 1
  fi
  
  local pattern="$1"
  local -a matches=()
  
  while IFS= read -r match; do
    [[ -n "$match" ]] && matches+=("$match")
  done < <(find_matching_sessions "$pattern")
  
  if [[ ${#matches[@]} -eq 0 ]]; then
    log_error "No sessions matching '$pattern'"
    echo "" >&2
    echo "Available sessions:" >&2
    poll_sessions_cmd >&2
    return 1
  fi
  
  local selected
  selected=$(select_session "${matches[@]}") || return 1
  
  local session="${selected%%|*}"
  local key="${selected#*|}"
  
  log "Attaching to: $session ($key)"
  exec tmux attach -t "$session"
}

# =============================================================================
# Subcommand: logs
# =============================================================================

poll_logs_cmd() {
  local follow=false
  local poll_filter=""
  local lines=50
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --follow|-f) follow=true; shift ;;
      --poll) poll_filter="$2"; shift 2 ;;
      --lines|-n) lines="$2"; shift 2 ;;
      --help|-h)
        cat << 'EOF'
Usage: ocdc poll logs [options]

View poll orchestrator logs.

Options:
  --follow, -f       Follow log output (like tail -f)
  --poll <name>      Filter by poll config ID
  --lines, -n <num>  Number of lines to show (default: 50)
  --help             Show this help

Examples:
  ocdc poll logs                     # View recent logs
  ocdc poll logs --follow            # Follow logs in real-time
  ocdc poll logs --poll github-issues  # Filter by poll config
EOF
        return 0
        ;;
      *)
        log_error "Unknown option: $1"
        return 1
        ;;
    esac
  done
  
  if [[ ! -f "$OCDC_POLL_LOG_FILE" ]]; then
    log_warn "No log file found at $OCDC_POLL_LOG_FILE"
    return 0
  fi
  
  if [[ "$follow" == "true" ]]; then
    if [[ -n "$poll_filter" ]]; then
      tail -f "$OCDC_POLL_LOG_FILE" | grep --line-buffered "\\[$poll_filter\\]"
    else
      tail -f "$OCDC_POLL_LOG_FILE"
    fi
  else
    if [[ -n "$poll_filter" ]]; then
      grep "\\[$poll_filter\\]" "$OCDC_POLL_LOG_FILE" | tail -n "$lines"
    else
      tail -n "$lines" "$OCDC_POLL_LOG_FILE"
    fi
  fi
}

# Check required dependencies
check_dependencies() {
  local missing=()
  
  command -v jq >/dev/null 2>&1 || missing+=("jq")
  command -v tmux >/dev/null 2>&1 || missing+=("tmux")
  command -v opencode >/dev/null 2>&1 || missing+=("opencode")
  
  if [[ ${#missing[@]} -gt 0 ]]; then
    log_error "Missing required dependencies: ${missing[*]}"
    log_error "Install with: brew install ${missing[*]}"
    return 1
  fi
  return 0
}

# Sanitize a string to be safe for use in file paths and tmux session names
# Only allows alphanumeric characters, hyphens, underscores, and dots
sanitize_name() {
  local input="$1"
  echo "$input" | tr -cd '[:alnum:]-_.'
}

show_help() {
  cat << 'EOF'
Usage: ocdc poll [command] [options]

Poll configured sources and spawn OpenCode sessions for new items.
Automatically detects merged/closed PRs and cleans up resources.

Commands:
  sessions            List active poll-created sessions
  attach <pattern>    Attach to a session by key or name
  logs [options]      View poll logs
  clean [options]     Clean up orphaned sessions (alias for ocdc clean --sessions)

Options:
  --once              Run one poll cycle and exit (default behavior)
  --daemon            Run continuously, polling every interval
  --interval <secs>   Poll interval in seconds (default: 300, requires --daemon)
  --max-concurrent N  Process up to N items in parallel (default: 1)
  --dry-run           Show what would be done without executing
  --config <id>       Only run specific config by id
  --skip-cleanup      Skip cleanup detection phase (for debugging)
  --verbose           Show detailed output
  --help              Show this help

Cleanup:
  PRs/issues that are merged or closed are automatically detected.
  After a configurable grace period (default: 5 minutes), cleanup
  actions are executed: kill tmux session, stop container, optionally
  remove clone directory. Configure via 'cleanup' section in poll config.

Examples:
  ocdc poll                    # Run all enabled polls once
  ocdc poll --dry-run          # Preview what would happen
  ocdc poll --max-concurrent 3 # Process 3 items in parallel
  ocdc poll --config github-issues  # Run only github-issues poll
  ocdc poll sessions           # List active sessions
  ocdc poll attach issue-42    # Attach to a matching session
  ocdc poll logs --follow      # Follow poll logs
  ocdc poll clean              # Clean up orphaned sessions
EOF
}

# Check if an item has been processed
is_processed() {
  local key="$1"
  jq -e --arg key "$key" '.[$key] != null' "$STATE_FILE" >/dev/null 2>&1
}

# Mark an item as processed (with file locking to prevent race conditions)
mark_processed() {
  local key="$1"
  local config_id="$2"
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  
  # Use mkdir-based locking for cross-platform compatibility (flock not on macOS)
  lock_file "${STATE_FILE}.lock"
  # Ensure lock is released even if jq/mv fails (set -e would otherwise leave stale lock)
  trap 'unlock_file "${STATE_FILE}.lock"' EXIT
  
  local tmp
  tmp=$(mktemp)
  jq --arg key "$key" --arg config "$config_id" --arg ts "$timestamp" \
    '.[$key] = {config: $config, processed_at: $ts}' "$STATE_FILE" > "$tmp"
  mv "$tmp" "$STATE_FILE"
  
  trap - EXIT
  unlock_file "${STATE_FILE}.lock"
}

# Get item field using jq mapping
get_item_field() {
  local item_json="$1"
  local jq_expr="$2"
  
  echo "$item_json" | jq -r "$jq_expr"
}

# Expand ~ in paths
expand_path() {
  local path="$1"
  echo "${path/#\~/$HOME}"
}

# Process a single poll config
process_poll() {
  local config_file="$1"
  
  # Validate config before processing
  if ! poll_config_validate "$config_file"; then
    log_error "Invalid config file: $config_file"
    return 1
  fi
  
  # Also validate against JSON schema if available
  local schema_output
  if ! schema_output=$(poll_config_validate_schema "$config_file" 2>&1); then
    log_error "Config failed schema validation: $config_file"
    log_error "$schema_output"
    return 1
  fi
  
  local config_id
  config_id=$(poll_config_get "$config_file" ".id")
  
  # Set current poll ID for structured logging
  CURRENT_POLL_ID="$config_id"
  
  log "Processing poll: $config_id"
  
  # Check if enabled
  local enabled
  enabled=$(poll_config_get_with_default "$config_file" ".enabled" "true")
  if [[ "$enabled" != "true" ]]; then
    log "  Skipping (disabled)"
    return 0
  fi
  
  # Get effective fetch command (built from fetch options or fetch_command)
  local fetch_cmd
  fetch_cmd=$(poll_config_get_effective_fetch_command "$config_file")
  
  # Execute fetch command with error handling
  log "  Fetching items..."
  [[ "$VERBOSE" == "true" ]] && log "  Command: $fetch_cmd"
  local items_json fetch_output fetch_stderr fetch_exit_code
  # Capture stdout and stderr separately - MCP servers may output to stderr
  fetch_stderr=$(mktemp)
  fetch_output=$(bash -c "$fetch_cmd" 2>"$fetch_stderr") || fetch_exit_code=$?
  fetch_exit_code=${fetch_exit_code:-0}
  
  # Handle fetch errors based on exit code from ocdc-mcp-fetch.js
  # Exit codes: 0=success, 10=not configured, 11=connection failed, 12=tool not found, 13=tool failed
  if [[ $fetch_exit_code -ne 0 ]]; then
    local error_type="$ERR_NETWORK_TIMEOUT"  # Default
    local error_msg
    error_msg=$(cat "$fetch_stderr")
    rm -f "$fetch_stderr"
    
    case $fetch_exit_code in
      10)
        # MCP not configured - skip this source permanently
        error_type="$ERR_AUTH_FAILED"
        log_error "  MCP not configured for source type. Skipping."
        return 1
        ;;
      11)
        # Connection failed - could be rate limit or network issue
        if echo "$error_msg" | grep -qi "rate.limit\|429\|too.many.requests"; then
          error_type="$ERR_RATE_LIMITED"
          log_warn "  Rate limited. Will retry next cycle."
        else
          error_type="$ERR_NETWORK_TIMEOUT"
          log_warn "  Connection failed. Will retry next cycle."
        fi
        return 1
        ;;
      12)
        # Tool not found - likely auth issue or misconfiguration
        error_type="$ERR_AUTH_FAILED"
        log_error "  MCP tool not found. Check configuration."
        return 1
        ;;
      13)
        # Tool execution failed
        if echo "$error_msg" | grep -qi "rate.limit\|429\|too.many.requests"; then
          error_type="$ERR_RATE_LIMITED"
          log_warn "  Rate limited. Will retry next cycle."
        elif echo "$error_msg" | grep -qi "unauthorized\|forbidden\|401\|403"; then
          error_type="$ERR_AUTH_FAILED"
          log_error "  Authentication failed. Check credentials."
        else
          error_type="$ERR_NETWORK_TIMEOUT"
          log_warn "  Fetch failed. Will retry next cycle."
        fi
        return 1
        ;;
      *)
        log_error "  Fetch command failed (exit $fetch_exit_code): $error_msg"
        return 1
        ;;
    esac
  fi
  rm -f "$fetch_stderr"
  
  items_json="$fetch_output"
  
  # Check if we got valid JSON array
  local item_count
  item_count=$(echo "$items_json" | jq -r 'length' 2>/dev/null || echo "0")
  log "  Found $item_count items"
  
  if [[ "$item_count" == "0" ]]; then
    return 0
  fi
  
  # Get effective mapping expressions (merged with defaults)
  local item_mapping_json
  item_mapping_json=$(poll_config_get_effective_item_mapping "$config_file")
  
  local key_expr repo_expr repo_short_expr number_expr title_expr body_expr url_expr branch_expr
  key_expr=$(echo "$item_mapping_json" | jq -r '.key')
  repo_expr=$(echo "$item_mapping_json" | jq -r '.repo')
  repo_short_expr=$(echo "$item_mapping_json" | jq -r '.repo_short')
  number_expr=$(echo "$item_mapping_json" | jq -r '.number')
  title_expr=$(echo "$item_mapping_json" | jq -r '.title')
  body_expr=$(echo "$item_mapping_json" | jq -r '.body')
  url_expr=$(echo "$item_mapping_json" | jq -r '.url')
  branch_expr=$(echo "$item_mapping_json" | jq -r '.branch')
  
  # Get effective prompt template (or default)
  local prompt_template
  prompt_template=$(poll_config_get_effective_prompt "$config_file")
  
  # Get effective session name template (or default)
  local session_template
  session_template=$(poll_config_get_effective_session_name "$config_file")
  
  # Get effective agent (or default based on source type)
  local session_agent
  session_agent=$(poll_config_get_effective_agent "$config_file")
  
  # Validate agent to prevent command injection from malicious configs
  case "$session_agent" in
    plan|code|architect|build|review|pm) ;;  # Known safe agents
    *)
      log_warn "Unknown agent '$session_agent', defaulting to 'plan'"
      session_agent="plan"
      ;;
  esac
  
  # Get source type (required in new schema)
  local source_type
  source_type=$(poll_config_get "$config_file" ".source_type")
  
  # Get repo filters for matching
  local repo_filters_json
  repo_filters_json=$(poll_config_get_repo_filters "$config_file")
  
  # Collect items that need processing
  local items_to_process=()
  
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    
    # Extract key for filtering
    local key
    key=$(get_item_field "$item" "$key_expr")
    
    # Check if item should be permanently skipped (non-retryable error)
    if poll_error_should_skip "$key"; then
      local error_info
      error_info=$(poll_error_get_info "$key")
      local error_type error_msg
      error_type=$(echo "$error_info" | jq -r '.type // "unknown"')
      error_msg=$(echo "$error_info" | jq -r '.message // ""')
      [[ "$VERBOSE" == "true" ]] && log "  Skipping $key (permanent error: $error_type - $error_msg)"
      continue
    fi
    
    # Check if already processed successfully
    if is_processed "$key"; then
      [[ "$VERBOSE" == "true" ]] && log "  Skipping $key (already processed)"
      continue
    fi
    
    # Check if item is in error state but ready for retry
    if poll_error_should_retry "$key"; then
      local error_info
      error_info=$(poll_error_get_info "$key")
      local attempts
      attempts=$(echo "$error_info" | jq -r '.attempts // 0')
      log "  Retrying item: $key (attempt $((attempts + 1)))"
      items_to_process+=("$item")
    elif poll_error_is_errored "$key"; then
      # In error state but not ready to retry yet
      local error_info
      error_info=$(poll_error_get_info "$key")
      local next_retry
      next_retry=$(echo "$error_info" | jq -r '.next_retry // ""')
      [[ "$VERBOSE" == "true" ]] && log "  Skipping $key (retry scheduled for $next_retry)"
      continue
    else
      # New item
      log "  New item: $key"
      items_to_process+=("$item")
    fi
  done < <(echo "$items_json" | jq -c '.[]')
  
  local items_count=${#items_to_process[@]}
  if [[ $items_count -eq 0 ]]; then
    log "  No new items to process"
    CURRENT_POLL_ID=""
    return 0
  fi
  
  log "  Processing $items_count item(s) (max concurrent: $MAX_CONCURRENT)"
  
  # Process items with parallelism
  local job_pids=()
  local active_jobs=0
  
  for item in "${items_to_process[@]}"; do
    # Wait for a slot if we're at max concurrent
    while [[ $active_jobs -ge $MAX_CONCURRENT ]]; do
      # Wait for any job to complete
      wait -n 2>/dev/null || true
      # Recount active jobs
      active_jobs=0
      for pid in "${job_pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
          active_jobs=$((active_jobs + 1))
        fi
      done
    done
    
    # Process item in background (or foreground if max_concurrent=1)
    if [[ $MAX_CONCURRENT -eq 1 ]]; then
      process_single_item "$item" "$config_id" "$source_type" \
        "$key_expr" "$repo_expr" "$repo_short_expr" "$number_expr" \
        "$title_expr" "$body_expr" "$url_expr" "$branch_expr" \
        "$session_template" "$prompt_template" "$session_agent" \
        "$repo_filters_json"
    else
      process_single_item "$item" "$config_id" "$source_type" \
        "$key_expr" "$repo_expr" "$repo_short_expr" "$number_expr" \
        "$title_expr" "$body_expr" "$url_expr" "$branch_expr" \
        "$session_template" "$prompt_template" "$session_agent" \
        "$repo_filters_json" &
      job_pids+=($!)
      active_jobs=$((active_jobs + 1))
    fi
  done
  
  # Wait for all remaining background jobs
  if [[ $MAX_CONCURRENT -gt 1 ]] && [[ ${#job_pids[@]} -gt 0 ]]; then
    wait "${job_pids[@]}" 2>/dev/null || true
  fi
  
  # Clear poll ID after processing
  CURRENT_POLL_ID=""
  
  return 0
}

# Process a single item - creates devcontainer and tmux session
# This function is called either directly or in a background subshell
process_single_item() {
  local item="$1"
  local config_id="$2"
  local source_type="$3"
  local key_expr="$4"
  local repo_expr="$5"
  local repo_short_expr="$6"
  local number_expr="$7"
  local title_expr="$8"
  local body_expr="$9"
  local url_expr="${10}"
  local branch_expr="${11}"
  local session_template="${12}"
  local prompt_template="${13}"
  local session_agent="${14}"
  local repo_filters_json="${15}"
  
  # Extract fields
  local key repo repo_short number title body url branch
  key=$(get_item_field "$item" "$key_expr")
  repo=$(get_item_field "$item" "$repo_expr")
  repo_short=$(get_item_field "$item" "$repo_short_expr")
  number=$(get_item_field "$item" "$number_expr")
  title=$(get_item_field "$item" "$title_expr")
  body=$(get_item_field "$item" "$body_expr")
  url=$(get_item_field "$item" "$url_expr")
  branch=$(get_item_field "$item" "$branch_expr")
  
  log "    [$key] Repo: $repo"
  log "    [$key] Branch: $branch"
  log "    [$key] Title: $title"
  
  # Match item against repo filters to get repo_path
  local repo_path
  repo_path=$(poll_config_match_repo_filter "$item" "$repo_filters_json")
  if [[ -z "$repo_path" ]]; then
    log_warn "    [$key] No matching repo_filter for item, skipping"
    [[ "$VERBOSE" == "true" ]] && log "    [$key] Item JSON: $item"
    return 1
  fi
  repo_path=$(expand_path "$repo_path")
  
  if [[ "$DRY_RUN" == "true" ]]; then
    log "    [$key] [DRY-RUN] Would create devcontainer and session"
    return 0
  fi
  
  # Check repo path exists
  if [[ ! -d "$repo_path" ]]; then
    log_error "    [$key] Repo path does not exist: $repo_path"
    poll_error_mark_item "$key" "$config_id" "$ERR_REPO_NOT_FOUND" "Repo path does not exist: $repo_path"
    return 1
  fi
  
  # Render templates
  local session_name_raw session_name
  session_name_raw=$(poll_config_render_template "$session_template" \
    key="$key" \
    repo="$repo" \
    repo_short="$repo_short" \
    number="$number" \
    title="$title" \
    branch="$branch")
  # Sanitize session name to prevent command injection and path traversal
  # Truncate to 200 chars to avoid tmux session name limits
  session_name=$(sanitize_name "$session_name_raw" | cut -c1-200)
  
  if [[ -z "$session_name" ]]; then
    log_error "    [$key] Session name is empty after sanitization"
    return 1
  fi
  
  local prompt
  prompt=$(poll_config_render_template "$prompt_template" \
    key="$key" \
    repo="$repo" \
    repo_short="$repo_short" \
    number="$number" \
    title="$title" \
    body="$body" \
    url="$url" \
    branch="$branch")
  
  # Create devcontainer clone
  log "    [$key] Creating devcontainer clone..."
  local clone_dir="${OCDC_CLONES_DIR}/${repo_short}/${branch}"
  
  if [[ ! -d "$clone_dir" ]]; then
    local clone_output clone_exit_code
    clone_output=$(cd "$repo_path" && ocdc up "$branch" --no-open 2>&1) || clone_exit_code=$?
    clone_exit_code=${clone_exit_code:-0}
    
    if [[ $clone_exit_code -ne 0 ]]; then
      # Determine if it's a clone failure or devcontainer failure
      local error_type="$ERR_CLONE_FAILED"
      if echo "$clone_output" | grep -qi "devcontainer\|container\|docker"; then
        error_type="$ERR_DEVCONTAINER_FAILED"
      fi
      
      log_error "    [$key] Failed to create devcontainer: $clone_output"
      poll_error_mark_item "$key" "$config_id" "$error_type" "$clone_output"
      return 1
    fi
  fi
  
  # Check if tmux session already exists
  if tmux has-session -t "$session_name" 2>/dev/null; then
    log_warn "    [$key] Session $session_name already exists"
    mark_processed "$key" "$config_id"
    return 0
  fi
  
  # Create tmux session with opencode
  log "    [$key] Creating tmux session: $session_name"
  
  # Write prompt to temp file to avoid shell escaping issues
  # Use sanitized session_name in filename to prevent path traversal
  local prompt_file
  prompt_file="${OCDC_POLL_STATE_DIR}/prompt-${session_name}.txt"
  printf '%s' "$prompt" > "$prompt_file"
  
  # Build opencode command with agent flag (quote to prevent injection)
  local opencode_cmd="opencode --agent \"$session_agent\""
  
  # Create tmux session running opencode with the prompt
  # Set OCDC_* environment variables so the plugin knows the context
  # The session runs in the clone directory
  local tmux_output tmux_exit_code
  tmux_output=$(tmux new-session -d -s "$session_name" -c "$clone_dir" \
    -e "OCDC_WORKSPACE=$clone_dir" \
    -e "OCDC_BRANCH=$branch" \
    -e "OCDC_SOURCE_URL=$url" \
    -e "OCDC_SOURCE_TYPE=$source_type" \
    -e "OCDC_POLL_CONFIG=$config_id" \
    -e "OCDC_ITEM_KEY=$key" \
    "$opencode_cmd --prompt \"\$(cat '$prompt_file')\"; rm -f '$prompt_file'; echo 'Session complete. Press enter to close...'; read" 2>&1) || tmux_exit_code=$?
  tmux_exit_code=${tmux_exit_code:-0}
  
  if [[ $tmux_exit_code -ne 0 ]]; then
    log_error "    [$key] Failed to create tmux session: $tmux_output"
    rm -f "$prompt_file"  # Cleanup prompt file on failure
    poll_error_mark_item "$key" "$config_id" "$ERR_DEVCONTAINER_FAILED" "tmux session creation failed: $tmux_output"
    return 1
  fi
  
  # Clear any previous error state on success (check if this was a retry)
  if poll_error_is_errored "$key"; then
    poll_error_clear_item "$key"
  fi
  
  log_success "    [$key] Session $session_name created"
  log "    [$key] Attach with: tmux attach -t $session_name"
  mark_processed "$key" "$config_id"
  return 0
}

# Main
main() {
  # Check for subcommands first (before option parsing)
  case "${1:-}" in
    sessions) shift; poll_sessions_cmd "$@"; exit $? ;;
    attach)   shift; poll_attach_cmd "$@"; exit $? ;;
    logs)     shift; poll_logs_cmd "$@"; exit $? ;;
    clean)    shift; exec "$SCRIPT_DIR/ocdc-clean" --sessions "$@" ;;
  esac
  
  # Parse arguments (check for --help first, before checking dependencies)
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --once)
        DAEMON=false
        shift
        ;;
      --daemon)
        DAEMON=true
        shift
        ;;
      --interval)
        INTERVAL="$2"
        shift 2
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --config)
        SINGLE_CONFIG="$2"
        shift 2
        ;;
      --verbose)
        VERBOSE=true
        shift
        ;;
      --skip-cleanup)
        SKIP_CLEANUP=true
        shift
        ;;
      --max-concurrent)
        if [[ -z "${2:-}" ]] || ! [[ "$2" =~ ^[0-9]+$ ]] || [[ "$2" -eq 0 ]]; then
          log_error "--max-concurrent must be a positive integer"
          exit 1
        fi
        MAX_CONCURRENT="$2"
        shift 2
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      *)
        log_error "Unknown option: $1"
        show_help
        exit 1
        ;;
    esac
  done
  
  # Check dependencies after parsing arguments
  check_dependencies || exit 1
  
  if [[ "$DAEMON" == "true" ]]; then
    log "Starting poll daemon (interval: ${INTERVAL}s)"
    while true; do
      run_poll_cycle
      log "Sleeping for ${INTERVAL}s..."
      sleep "$INTERVAL"
    done
  else
    run_poll_cycle
  fi
}

# Run one poll cycle
# Phases:
# 1. Cleanup detection: check active sessions for closed/merged PRs
# 2. Cleanup execution: process items in cleanup queue that are ready
# 3. Fetch and process: fetch new items and create sessions
run_poll_cycle() {
  # Find poll configs
  if [[ ! -d "$OCDC_POLLS_DIR" ]]; then
    log_warn "No polls directory found at $OCDC_POLLS_DIR"
    return 0
  fi
  
  # Phase 1: Cleanup detection (unless skipped)
  if [[ "$SKIP_CLEANUP" != "true" ]]; then
    run_cleanup_detection_phase
  fi
  
  # Phase 2: Cleanup execution (unless skipped or dry-run)
  if [[ "$SKIP_CLEANUP" != "true" ]] && [[ "$DRY_RUN" != "true" ]]; then
    run_cleanup_execution_phase
  fi
  
  # Phase 3: Fetch and process new items
  local found_configs=false
  
  for config_file in "$OCDC_POLLS_DIR"/*.yaml "$OCDC_POLLS_DIR"/*.yml; do
    [[ -f "$config_file" ]] || continue
    
    # If single config specified, skip others
    if [[ -n "$SINGLE_CONFIG" ]]; then
      local config_id
      config_id=$(poll_config_get "$config_file" ".id")
      if [[ "$config_id" != "$SINGLE_CONFIG" ]]; then
        continue
      fi
    fi
    
    found_configs=true
    process_poll "$config_file" || true
  done
  
  if [[ "$found_configs" == "false" ]]; then
    if [[ -n "$SINGLE_CONFIG" ]]; then
      log_error "Config '$SINGLE_CONFIG' not found"
      return 1
    else
      log "No poll configs found in $OCDC_POLLS_DIR"
    fi
  fi
  
  log "Poll cycle complete"
}

# =============================================================================
# Cleanup Detection Phase
# =============================================================================

# Check all active poll sessions for items that should be cleaned up
run_cleanup_detection_phase() {
  log "Checking for closed/merged items..."
  
  local sessions_json
  sessions_json=$(ocdc_list_poll_sessions)
  
  local session_count
  session_count=$(echo "$sessions_json" | jq 'length')
  
  if [[ "$session_count" == "0" ]]; then
    [[ "$VERBOSE" == "true" ]] && log "  No active poll sessions to check"
    return 0
  fi
  
  [[ "$VERBOSE" == "true" ]] && log "  Checking $session_count active session(s)"
  
  # Process each session
  echo "$sessions_json" | jq -c '.[]' | while read -r session; do
    local session_name source_type source_url item_key workspace poll_config
    session_name=$(echo "$session" | jq -r '.name')
    source_type=$(echo "$session" | jq -r '.source_type')
    source_url=$(echo "$session" | jq -r '.source_url')
    item_key=$(echo "$session" | jq -r '.item_key')
    workspace=$(echo "$session" | jq -r '.workspace')
    poll_config=$(echo "$session" | jq -r '.poll_config')
    
    # Skip if already queued for cleanup
    if cleanup_queue_is_queued "$item_key"; then
      [[ "$VERBOSE" == "true" ]] && log "  Skipping $item_key (already queued for cleanup)"
      continue
    fi
    
    # Skip if no source URL (can't check state)
    if [[ -z "$source_url" ]] || [[ "$source_url" == "null" ]]; then
      continue
    fi
    
    # Check if item should be cleaned up
    local state_result
    state_result=$(cleanup_check_source_state "$source_type" "$source_url")
    
    local should_cleanup reason
    should_cleanup=$(echo "$state_result" | jq -r '.should_cleanup')
    reason=$(echo "$state_result" | jq -r '.reason // empty')
    
    if [[ "$should_cleanup" == "true" ]]; then
      # Get cleanup config for this poll
      local cleanup_config delay
      cleanup_config=$(get_cleanup_config_for_poll "$poll_config")
      
      # Check if this reason triggers cleanup
      if ! cleanup_should_trigger_for_reason "$cleanup_config" "$reason"; then
        [[ "$VERBOSE" == "true" ]] && log "  Skipping $item_key ($reason not in cleanup triggers)"
        continue
      fi
      
      delay=$(echo "$cleanup_config" | jq -r '.delay // "5m"')
      
      log "  Detected $reason: $item_key"
      
      if [[ "$DRY_RUN" == "true" ]]; then
        log "  [DRY-RUN] Would queue for cleanup (delay: $delay)"
      else
        cleanup_queue_add \
          "$item_key" \
          "$poll_config" \
          "$reason" \
          "$session_name" \
          "$workspace" \
          "$source_url" \
          "$source_type" \
          "$delay"
        log "  Queued for cleanup (delay: $delay)"
      fi
    fi
  done
}

# Get cleanup config for a poll ID
# Returns JSON with cleanup config (with defaults applied)
get_cleanup_config_for_poll() {
  local poll_id="$1"
  
  # Find the config file for this poll ID
  local config_file
  for f in "$OCDC_POLLS_DIR"/*.yaml "$OCDC_POLLS_DIR"/*.yml; do
    [[ -f "$f" ]] || continue
    local id
    id=$(poll_config_get "$f" ".id" 2>/dev/null || true)
    if [[ "$id" == "$poll_id" ]]; then
      config_file="$f"
      break
    fi
  done
  
  if [[ -z "$config_file" ]]; then
    # Return defaults if config not found
    cleanup_get_config_with_defaults '{}'
    return 0
  fi
  
  # Get cleanup config from file
  local cleanup_json
  cleanup_json=$(poll_config_get "$config_file" ".cleanup // {}" 2>/dev/null || echo '{}')
  cleanup_get_config_with_defaults "$cleanup_json"
}

# =============================================================================
# Cleanup Execution Phase
# =============================================================================

# Process items in the cleanup queue that are ready
run_cleanup_execution_phase() {
  local ready_count=0
  
  # Count ready items first
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    ready_count=$((ready_count + 1))
  done < <(cleanup_queue_get_ready)
  
  if [[ $ready_count -eq 0 ]]; then
    [[ "$VERBOSE" == "true" ]] && log "No items ready for cleanup"
    return 0
  fi
  
  log "Processing $ready_count cleanup item(s)..."
  
  # Process each ready item
  while IFS= read -r item; do
    [[ -z "$item" ]] && continue
    
    local key tmux_session clone_path poll_id reason
    key=$(echo "$item" | jq -r '.key')
    tmux_session=$(echo "$item" | jq -r '.tmux_session')
    clone_path=$(echo "$item" | jq -r '.clone_path')
    poll_id=$(echo "$item" | jq -r '.poll_id')
    reason=$(echo "$item" | jq -r '.reason')
    
    log "  Cleaning up: $key ($reason)"
    
    # Get cleanup actions from config
    local cleanup_config actions_json
    cleanup_config=$(get_cleanup_config_for_poll "$poll_id")
    actions_json=$(echo "$cleanup_config" | jq -c '.actions')
    
    # Execute cleanup
    cleanup_execute_all "$tmux_session" "$clone_path" "$actions_json"
    
    # Remove from queue
    cleanup_queue_remove "$key"
    
    # Clear from processed.json state
    if [[ -f "$STATE_FILE" ]]; then
      local tmp
      tmp=$(mktemp)
      if jq --arg key "$key" 'del(.[$key])' "$STATE_FILE" > "$tmp" 2>/dev/null; then
        mv "$tmp" "$STATE_FILE"
      else
        rm -f "$tmp"
      fi
    fi
    
    log_success "  Completed cleanup: $key"
  done < <(cleanup_queue_get_ready)
}

main "$@"
