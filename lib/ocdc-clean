#!/usr/bin/env bash
#
# ocdc-clean - Clean up orphaned clones
#
# Orphaned clones are directories in the clones folder that have no
# associated tracked devcontainer instance in ports.json.
#
# Workspaces with uncommitted or unpushed changes are skipped (unless --force).
#
# Usage:
#   ocdc clean              # Clean orphaned clones
#   ocdc clean --dry-run    # Show what would be removed
#   ocdc clean --force      # Remove even if git dirty (DANGEROUS)
#
# Options:
#   --dry-run, -n      Show what would be removed without removing
#   --force, -f        Remove even if git dirty (use with caution!)
#
# Related commands:
#   ocdc list    - List instances and clones
#   ocdc down    - Stop devcontainer
#   ocdc tui     - Interactive TUI

set -euo pipefail

# Source paths library
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/ocdc-paths.bash"

PORTS_FILE="$OCDC_PORTS_FILE"
CLONES_DIR="$OCDC_CLONES_DIR"

# Parse arguments
DRY_RUN=false
FORCE=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run|-n)
      DRY_RUN=true
      shift
      ;;
    --force|-f)
      FORCE=true
      shift
      ;;
    --help|-h)
      sed -n '2,/^$/p' "$0" | sed 's/^# //' | sed 's/^#//'
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
  esac
done

log() { echo "[ocdc-clean] $*"; }
warn() { echo "[ocdc-clean] WARNING: $*"; }
error() { echo "[ocdc-clean] ERROR: $*" >&2; exit 1; }

# Get tracked workspaces from ports.json
get_tracked_workspaces() {
  if [[ -f "$PORTS_FILE" ]]; then
    jq -r 'keys[]' "$PORTS_FILE" 2>/dev/null || true
  fi
}

# Find orphaned clones
# Returns lines: "clone_dir|repo|branch|safe|reason"
find_orphaned_clones() {
  local tracked
  tracked=$(get_tracked_workspaces)
  
  if [[ ! -d "$CLONES_DIR" ]]; then
    return
  fi
  
  for repo_dir in "$CLONES_DIR"/*/; do
    [[ -d "$repo_dir" ]] || continue
    
    for clone_dir in "$repo_dir"*/; do
      [[ -d "$clone_dir" ]] || continue
      clone_dir="${clone_dir%/}"
      
      # Resolve symlinks for consistent comparison (macOS /var -> /private/var)
      local resolved_clone
      resolved_clone=$(ocdc_resolve_path "$clone_dir")
      
      # Check if this clone is tracked (compare both original and resolved paths)
      if ! echo "$tracked" | grep -qFx "$clone_dir" && \
         ! echo "$tracked" | grep -qFx "$resolved_clone"; then
        local repo=$(basename "$(dirname "$clone_dir")")
        local branch=$(basename "$clone_dir")
        
        # Check if safe to remove
        local safe="true"
        local reason=""
        
        if [[ "$FORCE" != "true" ]]; then
          local git_status
          git_status=$(ocdc_get_git_status "$clone_dir")
          local clean pushed
          clean=$(echo "$git_status" | jq -r '.clean')
          pushed=$(echo "$git_status" | jq -r '.pushed')
          
          if [[ "$clean" == "false" ]]; then
            safe="false"
            reason="uncommitted changes"
          elif [[ "$pushed" == "false" ]]; then
            safe="false"
            reason="unpushed commits"
          fi
        fi
        
        echo "${clone_dir}|${repo}|${branch}|${safe}|${reason}"
      fi
    done
  done
}

# Remove a clone directory
remove_clone() {
  local clone_dir="$1"
  local repo="$2"
  local branch="$3"
  
  rm -rf "$clone_dir"
  log "Removed clone: $repo/$branch"
  
  # Clean up empty parent directory
  local parent=$(dirname "$clone_dir")
  if [[ -d "$parent" ]] && [[ -z "$(ls -A "$parent")" ]]; then
    rmdir "$parent" 2>/dev/null || true
  fi
}

# Main
main() {
  local orphaned_clones=""
  local clones_to_remove=""
  local clones_skipped=""
  
  # Find orphaned clones
  orphaned_clones=$(find_orphaned_clones)
  
  # Check if anything to clean
  if [[ -z "$orphaned_clones" ]]; then
    log "No orphaned clones found."
    exit 0
  fi
  
  # Separate safe and unsafe clones
  local clone_count=0
  local clone_safe_count=0
  local clone_skip_count=0
  
  while IFS='|' read -r clone_dir repo branch safe reason; do
    [[ -z "$clone_dir" ]] && continue
    ((clone_count++)) || true
    
    if [[ "$safe" == "true" ]]; then
      clones_to_remove="${clones_to_remove}${clone_dir}|${repo}|${branch}\n"
      ((clone_safe_count++)) || true
    else
      clones_skipped="${clones_skipped}${clone_dir}|${repo}|${branch}|${reason}\n"
      ((clone_skip_count++)) || true
    fi
  done <<< "$orphaned_clones"
  
  # Dry run output
  if [[ "$DRY_RUN" == "true" ]]; then
    if [[ $clone_safe_count -gt 0 ]]; then
      log "Would remove $clone_safe_count orphaned clone(s):"
      echo -e "$clones_to_remove" | while IFS='|' read -r clone_dir repo branch; do
        [[ -z "$clone_dir" ]] && continue
        echo "  - $repo/$branch"
        echo "    $clone_dir"
      done
    fi
    
    if [[ $clone_skip_count -gt 0 ]]; then
      log "Would skip $clone_skip_count clone(s) (unsafe):"
      echo -e "$clones_skipped" | while IFS='|' read -r clone_dir repo branch reason; do
        [[ -z "$clone_dir" ]] && continue
        echo "  - $repo/$branch ($reason)"
      done
    fi
    
    exit 0
  fi
  
  # Perform cleanup
  log "Cleaning orphaned clones..."
  
  local removed_clones=0
  
  # Remove safe clones
  if [[ -n "$clones_to_remove" ]]; then
    echo -e "$clones_to_remove" | while IFS='|' read -r clone_dir repo branch; do
      [[ -z "$clone_dir" ]] && continue
      remove_clone "$clone_dir" "$repo" "$branch"
    done
    removed_clones=$clone_safe_count
  fi
  
  # Report skipped
  if [[ $clone_skip_count -gt 0 ]]; then
    log ""
    log "Skipped $clone_skip_count clone(s):"
    echo -e "$clones_skipped" | while IFS='|' read -r clone_dir repo branch reason; do
      [[ -z "$clone_dir" ]] && continue
      log "  - $repo/$branch ($reason)"
    done
    log ""
    log "Use --force to remove anyway (DANGEROUS - may lose uncommitted work)"
  fi
  
  # Summary
  log ""
  if [[ $removed_clones -gt 0 ]]; then
    log "Cleaned: ${removed_clones} clone(s)"
  fi
  
  log "Done."
}

main
